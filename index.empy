@# -*- html -*-

@{page_id = "overview"}
@{page_title = "Compiler cache"}
@empy.include("header.empy")

<p>ccache (or “Ccache”) is a compiler cache. It
<a href="performance.html">speeds up recompilation</a> by caching previous
compilations and detecting when the same compilation is being done again.
Supported languages are C, C++, Objective-C and Objective-C++.</p>

<p>ccache is free software, released under
the <a href="http://www.gnu.org/licenses/gpl.html">GNU General Public License
version 3</a> or later. See also the <a href="license.html">license
page</a>.</p>

<h2>Latest news</h2>

@{
import yaml
news = list(yaml.load_all(open("news.yaml")))
}@

<ul class="news">
@[for x in news[:5]]
    <li><i>@(x["date"]):</i> <a href="news.html#@(x["date"])"><b>@(x["header"])</b></a></li>
@[end for]
</ul>

<p class="news">
<a href="news.html">All news</a>
</p>


<h2>Features</h2>

<ul>
<li>Keeps statistics on hits/misses.</li>
<li>Automatic cache size management.</li>
<li>Can cache compilations that generate warnings.</li>
<li>Easy installation.</li>
<li>Low overhead.</li>
<li>Optionally uses hard links where possible to avoid copies.</li>
</ul>

<h2>Limitations</h2>

<ul>
<li>Only knows how to cache the compilation of a single
C/C++/Objective-C/Objective-C++ file. Other types of compilations (multi-file
compilation, linking, etc) will silently fall back to running the real
compiler.</li>
<li>Only works with <a href="http://gcc.gnu.org">GCC</a> and compilers that
behave similar enough.</li>
<li>Some compiler flags are not supported. If such a flag is detected, ccache
will silently fall back to running the real compiler.</li>
</ul>

<h2>Why bother?</h2>

<p>If you ever run <code>make clean; make</code>, you can probably benefit from
ccache. It is common for developers to do a clean build of a project for a
whole host of reasons, and this throws away all the information from your
previous compilations. By using ccache, recompilation goes much faster.</p>

<p>Another reason to use ccache is that the same cache is used for builds in
different directories. If you have several versions or branches of a software
stored in different directories, many of the object files in a build directory
can probably be taken from the cache even if they were compiled for another
version or branch.</p>

<p>A third scenario is using ccache to speed up clean builds performed by
servers or build farms that regularly check that the code is buildable.</p>

<p>You can also share the cache between users, which can be very useful on
shared compilation servers.</p>

<h2>Is it safe?</h2>

<p>The most important aspect of a compiler cache is to always produce exactly
the same output that the real compiler would produce. This includes providing
exactly the same object files and exactly the same compiler warnings that would
be produced if you use the real compiler. The only way you should be able to
tell that you are using ccache is the speed.</p>

<p>ccache of course tries to provide these guarantees. However:</p>

<ul>
  <li>
    Compilers are moving targets. Newer compiler versions may, and often do,
    introduce features that ccache can't foresee. In some cases it's also very
    hard for ccache to handle the compiler behaviors in a good way, especially
    in a way that is backward compatible with legacy compilers.
  </li>
  <li>
    There are some known corner cases where ccache can fail to detect that
    source code files have changed since a previous compilation. These
    limitations are listed
    under <a href="manual/latest.html#_caveats">caveats</a> in the manual.
  </li>
</ul>

<p>If you experience any bugs or undocumented limitations, please
<a href="bugs.html">report them</a>.</p>

@empy.include("footer.empy")
